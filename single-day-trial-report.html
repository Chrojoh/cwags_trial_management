<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Single-Day Trial Report</title>
    
    <!-- Firebase SDKs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-app-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-auth-compat.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.23.0/firebase-firestore-compat.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            background: white;
            padding: 1.5rem;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .controls {
            background: white;
            border-radius: 15px;
            padding: 2rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }

        .control-row {
            display: flex;
            gap: 1rem;
            align-items: end;
            margin-bottom: 1rem;
        }

        .control-group {
            flex: 1;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #2c3e50;
        }

        .control-group select {
            width: 100%;
            padding: 0.8rem;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
        }

        .btn {
            padding: 0.8rem 1.5rem;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            text-decoration: none;
            display: inline-block;
            white-space: nowrap;
        }

        .btn:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .discipline-tabs {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 0.5rem;
            margin-bottom: 1.5rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .discipline-tab {
            flex: 1;
            min-width: 150px;
            padding: 0.75rem 1rem;
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            text-align: center;
            transition: all 0.3s ease;
        }

        .discipline-tab:hover {
            border-color: #667eea;
            color: #667eea;
        }

        .discipline-tab.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .report-container {
            background: white;
            border-radius: 15px;
            padding: 2rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
            display: none;
        }

        .report-header {
            text-align: center;
            margin-bottom: 2rem;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 1rem;
        }

        .report-title {
            font-size: 1.8rem;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .report-info {
            color: #6c757d;
            font-size: 1.1rem;
        }

        .report-table-container {
            overflow-x: auto;
            margin-bottom: 2rem;
        }

        .report-table {
            width: 100%;
            border-collapse: collapse;
            min-width: 1000px;
        }

        .report-table th,
        .report-table td {
            border: 1px solid #dee2e6;
            padding: 0.5rem;
            text-align: left;
            vertical-align: middle;
            font-size: 0.85rem;
        }

        .report-table th {
            background: #f8f9fa;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            text-align: center;
        }

        .cwags-col { width: 100px; }
        .dog-col { width: 80px; }
        .handler-col { width: 120px; }
        .date-col { width: 80px; }
        .class-col { width: 120px; }
        .round-col { width: 50px; }
        .result-col { width: 60px; }
        .judge-col { width: 100px; }
        .comments-col { width: 150px; }

        .result-pass { color: #28a745; font-weight: bold; }
        .result-fail { color: #dc3545; font-weight: bold; }
        .result-games { color: #17a2b8; font-weight: bold; }
        .result-absent { color: #6c757d; font-style: italic; }

        .status-message {
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 8px;
            display: none;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-info {
            background: #cce7ff;
            color: #0056b3;
            border: 1px solid #99d3ff;
        }

        .no-data {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            padding: 3rem;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .export-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
        }

        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stat-card {
            background: white;
            padding: 1rem;
            border-radius: 6px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.8rem;
            margin-top: 0.25rem;
        }

        @media (max-width: 768px) {
            .control-row {
                flex-direction: column;
            }
            
            .discipline-tabs {
                flex-direction: column;
            }
            
            .discipline-tab {
                min-width: auto;
            }
            
            .export-buttons {
                flex-direction: column;
            }
            
            .report-table {
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div>
                <h1>üìä Single-Day Trial Report</h1>
                <p>Generate detailed trial reports by discipline with individual run entries</p>
            </div>
            <div>
                <a href="trial-secretary-dashboard.html" class="btn btn-secondary">‚Üê Back to Dashboard</a>
            </div>
        </div>

        <!-- Status Message -->
        <div class="status-message" id="statusMessage"></div>

        <!-- Controls -->
        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label for="trialSelect">Select Trial:</label>
                    <select id="trialSelect" onchange="loadTrialData()">
                        <option value="">Loading trials...</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="daySelect">Select Day:</label>
                    <select id="daySelect" onchange="generateReports()">
                        <option value="">Select a trial first</option>
                    </select>
                </div>
                <button class="btn" onclick="generateReports()">üìã Generate Reports</button>
            </div>
        </div>

        <!-- Discipline Tabs -->
        <div class="discipline-tabs" id="disciplineTabs" style="display: none;">
            <div class="discipline-tab active" onclick="showDiscipline('scent')">Scent (Detective)</div>
            <div class="discipline-tab" onclick="showDiscipline('games')">Games</div>
            <div class="discipline-tab" onclick="showDiscipline('obedience')">Rally Obedience</div>
            <div class="discipline-tab" onclick="showDiscipline('ranger')">Ranger/Dasher</div>
        </div>

        <!-- Report Containers -->
        <div class="report-container active" id="scentReport">
            <div class="report-header">
                <div class="report-title">Scent (Detective) Disciplines Report</div>
                <div class="report-info" id="scentReportInfo">Trial ‚Ä¢ Date ‚Ä¢ Entries</div>
            </div>
            
            <div class="stats-section" id="scentStats"></div>
            
            <div class="report-table-container">
                <table class="report-table">
                    <thead>
                        <tr>
                            <th class="cwags-col">C-WAGS #</th>
                            <th class="dog-col">Call Name</th>
                            <th class="handler-col">Handler</th>
                            <th class="date-col">Date</th>
                            <th class="class-col">Class</th>
                            <th class="round-col">Round</th>
                            <th class="result-col">Result</th>
                            <th class="judge-col">Judge</th>
                            <th class="comments-col">Comments</th>
                        </tr>
                    </thead>
                    <tbody id="scentTableBody">
                        <!-- Scent entries will be generated here -->
                    </tbody>
                </table>
            </div>

            <div class="export-buttons">
                <button class="btn btn-success" onclick="exportDisciplineCSV('scent')">üìÑ Export Scent CSV</button>
                <button class="btn btn-warning" onclick="exportDisciplinePDF('scent')">üìë Export Scent PDF</button>
            </div>
        </div>

        <div class="report-container" id="gamesReport">
            <div class="report-header">
                <div class="report-title">Games Disciplines Report</div>
                <div class="report-info" id="gamesReportInfo">Trial ‚Ä¢ Date ‚Ä¢ Entries</div>
            </div>
            
            <div class="stats-section" id="gamesStats"></div>
            
            <div class="report-table-container">
                <table class="report-table">
                    <thead>
                        <tr>
                            <th class="cwags-col">C-WAGS #</th>
                            <th class="dog-col">Call Name</th>
                            <th class="handler-col">Handler</th>
                            <th class="date-col">Date</th>
                            <th class="class-col">Class</th>
                            <th class="round-col">Round</th>
                            <th class="result-col">Result</th>
                            <th class="judge-col">Judge</th>
                            <th class="comments-col">Comments</th>
                        </tr>
                    </thead>
                    <tbody id="gamesTableBody">
                        <!-- Games entries will be generated here -->
                    </tbody>
                </table>
            </div>

            <div class="export-buttons">
                <button class="btn btn-success" onclick="exportDisciplineCSV('games')">üìÑ Export Games CSV</button>
                <button class="btn btn-warning" onclick="exportDisciplinePDF('games')">üìë Export Games PDF</button>
            </div>
        </div>

        <div class="report-container" id="obedienceReport">
            <div class="report-header">
                <div class="report-title">Rally Obedience Disciplines Report</div>
                <div class="report-info" id="obedienceReportInfo">Trial ‚Ä¢ Date ‚Ä¢ Entries</div>
            </div>
            
            <div class="stats-section" id="obedienceStats"></div>
            
            <div class="report-table-container">
                <table class="report-table">
                    <thead>
                        <tr>
                            <th class="cwags-col">C-WAGS #</th>
                            <th class="dog-col">Call Name</th>
                            <th class="handler-col">Handler</th>
                            <th class="date-col">Date</th>
                            <th class="class-col">Class</th>
                            <th class="round-col">Round</th>
                            <th class="result-col">Result</th>
                            <th class="judge-col">Judge</th>
                            <th class="comments-col">Comments</th>
                        </tr>
                    </thead>
                    <tbody id="obedienceTableBody">
                        <!-- Obedience entries will be generated here -->
                    </tbody>
                </table>
            </div>

            <div class="export-buttons">
                <button class="btn btn-success" onclick="exportDisciplineCSV('obedience')">üìÑ Export Obedience CSV</button>
                <button class="btn btn-warning" onclick="exportDisciplinePDF('obedience')">üìë Export Obedience PDF</button>
            </div>
        </div>

        <div class="report-container" id="rangerReport">
            <div class="report-header">
                <div class="report-title">Ranger/Dasher Disciplines Report</div>
                <div class="report-info" id="rangerReportInfo">Trial ‚Ä¢ Date ‚Ä¢ Entries</div>
            </div>
            
            <div class="stats-section" id="rangerStats"></div>
            
            <div class="report-table-container">
                <table class="report-table">
                    <thead>
                        <tr>
                            <th class="cwags-col">C-WAGS #</th>
                            <th class="dog-col">Call Name</th>
                            <th class="handler-col">Handler</th>
                            <th class="date-col">Date</th>
                            <th class="class-col">Class</th>
                            <th class="round-col">Round</th>
                            <th class="result-col">Result</th>
                            <th class="judge-col">Judge</th>
                            <th class="comments-col">Comments</th>
                        </tr>
                    </thead>
                    <tbody id="rangerTableBody">
                        <!-- Ranger/Dasher entries will be generated here -->
                    </tbody>
                </table>
            </div>

            <div class="export-buttons">
                <button class="btn btn-success" onclick="exportDisciplineCSV('ranger')">üìÑ Export Ranger CSV</button>
                <button class="btn btn-warning" onclick="exportDisciplinePDF('ranger')">üìë Export Ranger PDF</button>
            </div>
        </div>

        <!-- No Data Message -->
        <div class="no-data" id="noDataMessage" style="display: none;">
            <h3>üìã No Trial Data Available</h3>
            <p>Please select a trial and day to generate reports.</p>
        </div>
    </div>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBWpyM_lEpqdQWuKuLLZiW1SlloWsWkJCs",
            authDomain: "dog-trialing-system.firebaseapp.com",
            projectId: "dog-trialing-system",
            storageBucket: "dog-trialing-system.firebasestorage.app",
            messagingSenderId: "490812593982",
            appId: "1:490812593982:web:344776707566f8d9027e6f",
            measurementId: "G-EMLX58Y278"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        // ========================================
// ROUND KEY UTILITY FUNCTIONS
// ========================================

/**
 * Generate a standardized round key
 * @param {number} dayIndex - Day index (0-based)
 * @param {number} classIndex - Class index (0-based)
 * @param {number} roundIndex - Round index (0-based)
 * @returns {string} Standardized round key "dayIndex-classIndex-roundIndex"
 */
function generateRoundKey(dayIndex, classIndex, roundIndex) {
    // Ensure all inputs are integers
    const day = parseInt(dayIndex) || 0;
    const cls = parseInt(classIndex) || 0;
    const round = parseInt(roundIndex) || 0;
    
    return `${day}-${cls}-${round}`;
}

/**
 * Parse a round key into its components
 * @param {string} roundKey - Round key to parse
 * @returns {object} Object with dayIndex, classIndex, roundIndex
 */
function parseRoundKey(roundKey) {
    if (!roundKey || typeof roundKey !== 'string') {
        throw new Error(`Invalid round key: ${roundKey}`);
    }
    
    const parts = roundKey.split('-');
    if (parts.length !== 3) {
        throw new Error(`Invalid round key format: ${roundKey}. Expected format: dayIndex-classIndex-roundIndex`);
    }
    
    const dayIndex = parseInt(parts[0]);
    const classIndex = parseInt(parts[1]);
    const roundIndex = parseInt(parts[2]);
    
    if (isNaN(dayIndex) || isNaN(classIndex) || isNaN(roundIndex)) {
        throw new Error(`Round key contains non-numeric values: ${roundKey}`);
    }
    
    return {
        dayIndex,
        classIndex,
        roundIndex
    };
}

/**
 * Validate if a round key follows the standard format
 * @param {string} roundKey - Round key to validate
 * @returns {boolean} True if valid, false otherwise
 */
function validateRoundKey(roundKey) {
    try {
        if (!roundKey || typeof roundKey !== 'string') return false;
        
        // Check for common malformed patterns
        if (roundKey.includes('--')) return false; // Double dash
        if (roundKey.includes('_')) return false;  // Underscore
        if (roundKey.includes('.')) return false;  // Dot
        if (roundKey.includes(' ')) return false;  // Space
        
        const parts = roundKey.split('-');
        if (parts.length !== 3) return false;
        
        // Check if all parts are valid integers
        return parts.every(part => {
            const num = parseInt(part);
            return !isNaN(num) && num >= 0 && part === num.toString();
        });
    } catch (error) {
        return false;
    }
}

/**
 * Fix common round key formatting issues
 * @param {string} malformedKey - Malformed round key
 * @returns {string|null} Fixed round key or null if unable to fix
 */
function fixRoundKey(malformedKey) {
    if (!malformedKey || typeof malformedKey !== 'string') {
        return null;
    }
    
    console.log(`üîß Attempting to fix round key: "${malformedKey}"`);
    
    let fixed = malformedKey;
    
    // Fix double dash issue: "0--1-0" -> "0-1-0"
    fixed = fixed.replace(/--+/g, '-');
    
    // Fix underscore separators: "0_1_0" -> "0-1-0"
    fixed = fixed.replace(/_/g, '-');
    
    // Fix dot separators: "0.1.0" -> "0-1-0"
    fixed = fixed.replace(/\./g, '-');
    
    // Remove spaces
    fixed = fixed.replace(/\s/g, '');
    
    // Handle malformed keys like "0--1-0" where there's an empty part
    const parts = fixed.split('-');
    const cleanParts = parts.filter(part => part !== '');
    
    if (cleanParts.length === 3) {
        fixed = cleanParts.join('-');
    }
    
    // Validate the result
    if (validateRoundKey(fixed)) {
        console.log(`‚úÖ Fixed round key: "${malformedKey}" -> "${fixed}"`);
        return fixed;
    }
    
    console.log(`‚ùå Unable to fix round key: "${malformedKey}"`);
    return null;
}

/**
 * Process round key with backwards compatibility
 * Handles both old malformed keys and new standard keys
 * @param {string} roundKey - Round key to process
 * @returns {object} Parsed round key data with original and fixed keys
 */
function processRoundKey(roundKey) {
    const result = {
        original: roundKey,
        fixed: null,
        isValid: false,
        dayIndex: null,
        classIndex: null,
        roundIndex: null,
        needsFix: false
    };
    
    // Check if already valid
    if (validateRoundKey(roundKey)) {
        result.fixed = roundKey;
        result.isValid = true;
        result.needsFix = false;
        
        try {
            const parsed = parseRoundKey(roundKey);
            result.dayIndex = parsed.dayIndex;
            result.classIndex = parsed.classIndex;
            result.roundIndex = parsed.roundIndex;
        } catch (error) {
            console.error('Error parsing valid round key:', error);
        }
    } else {
        // Try to fix the key
        const fixed = fixRoundKey(roundKey);
        if (fixed) {
            result.fixed = fixed;
            result.isValid = true;
            result.needsFix = true;
            
            try {
                const parsed = parseRoundKey(fixed);
                result.dayIndex = parsed.dayIndex;
                result.classIndex = parsed.classIndex;
                result.roundIndex = parsed.roundIndex;
            } catch (error) {
                console.error('Error parsing fixed round key:', error);
                result.isValid = false;
            }
        }
    }
    
    return result;
}

// ========================================
// DATA MIGRATION FUNCTIONS
// ========================================

/**
 * Scan and report round key issues in running orders
 * @param {string} trialId - Trial ID to scan
 * @returns {Promise<object>} Report of issues found
 */
async function scanRunningOrderKeys(trialId) {
    try {
        console.log(`üîç Scanning running order keys for trial: ${trialId}`);
        
        const orderDoc = await db.collection('running_orders').doc(trialId).get();
        if (!orderDoc.exists) {
            return { error: 'No running order found' };
        }
        
        const data = orderDoc.data();
        const report = {
            trialId,
            validKeys: [],
            invalidKeys: [],
            fixableKeys: [],
            unfixableKeys: [],
            totalKeys: 0
        };
        
        // Check different possible data structures
        const dataToCheck = data.finalizedRunningOrders || data.generatedSheets || data.roundOrders || {};
        
        Object.keys(dataToCheck).forEach(roundKey => {
            report.totalKeys++;
            
            if (validateRoundKey(roundKey)) {
                report.validKeys.push(roundKey);
            } else {
                report.invalidKeys.push(roundKey);
                
                const fixed = fixRoundKey(roundKey);
                if (fixed) {
                    report.fixableKeys.push({ original: roundKey, fixed });
                } else {
                    report.unfixableKeys.push(roundKey);
                }
            }
        });
        
        console.log('üìä Round key scan results:', report);
        return report;
        
    } catch (error) {
        console.error('Error scanning round keys:', error);
        return { error: error.message };
    }
}

/**
 * Fix round keys in running orders for a trial
 * @param {string} trialId - Trial ID to fix
 * @param {boolean} dryRun - If true, don't actually update, just report what would be done
 * @returns {Promise<object>} Results of the fix operation
 */
async function fixRunningOrderKeys(trialId, dryRun = true) {
    try {
        console.log(`üîß ${dryRun ? 'DRY RUN: ' : ''}Fixing running order keys for trial: ${trialId}`);
        
        const orderDoc = await db.collection('running_orders').doc(trialId).get();
        if (!orderDoc.exists) {
            return { error: 'No running order found' };
        }
        
        const data = orderDoc.data();
        const updates = {};
        const results = {
            trialId,
            fixed: [],
            skipped: [],
            errors: [],
            dryRun
        };
        
        // Process different possible data structures
        ['finalizedRunningOrders', 'generatedSheets', 'roundOrders'].forEach(fieldName => {
            if (data[fieldName]) {
                updates[fieldName] = {};
                
                Object.entries(data[fieldName]).forEach(([roundKey, roundData]) => {
                    if (validateRoundKey(roundKey)) {
                        // Key is already valid, keep as-is
                        updates[fieldName][roundKey] = roundData;
                        results.skipped.push(roundKey);
                    } else {
                        // Try to fix the key
                        const fixed = fixRoundKey(roundKey);
                        if (fixed) {
                            updates[fieldName][fixed] = roundData;
                            results.fixed.push({ original: roundKey, fixed });
                        } else {
                            // Keep original if can't fix
                            updates[fieldName][roundKey] = roundData;
                            results.errors.push(`Unable to fix key: ${roundKey}`);
                        }
                    }
                });
            }
        });
        
        // Apply updates if not dry run
        if (!dryRun && results.fixed.length > 0) {
            await db.collection('running_orders').doc(trialId).update(updates);
            console.log(`‚úÖ Updated ${results.fixed.length} round keys in running orders`);
        }
        
        console.log('üîß Fix results:', results);
        return results;
        
    } catch (error) {
        console.error('Error fixing round keys:', error);
        return { error: error.message };
    }
}

/**
 * Fix round keys in scores collection
 * @param {string} trialId - Trial ID to fix scores for
 * @param {boolean} dryRun - If true, don't actually update
 * @returns {Promise<object>} Results of the fix operation
 */
async function fixScoreKeys(trialId, dryRun = true) {
    try {
        console.log(`üîß ${dryRun ? 'DRY RUN: ' : ''}Fixing score keys for trial: ${trialId}`);
        
        const scoresSnapshot = await db.collection('scores')
            .where('trialId', '==', trialId)
            .get();
        
        const results = {
            trialId,
            fixed: [],
            skipped: [],
            errors: [],
            dryRun
        };
        
        const batch = db.batch();
        let batchCount = 0;
        
        scoresSnapshot.forEach(doc => {
            const data = doc.data();
            const roundKey = data.roundKey;
            
            if (!roundKey) {
                results.errors.push(`Score document ${doc.id} has no roundKey`);
                return;
            }
            
            if (validateRoundKey(roundKey)) {
                results.skipped.push(roundKey);
                return;
            }
            
            const fixed = fixRoundKey(roundKey);
            if (fixed) {
                if (!dryRun) {
                    batch.update(doc.ref, { roundKey: fixed });
                    batchCount++;
                }
                results.fixed.push({ docId: doc.id, original: roundKey, fixed });
            } else {
                results.errors.push(`Unable to fix roundKey in doc ${doc.id}: ${roundKey}`);
            }
        });
        
        // Commit batch if not dry run
        if (!dryRun && batchCount > 0) {
            await batch.commit();
            console.log(`‚úÖ Updated ${batchCount} score documents`);
        }
        
        console.log('üîß Score fix results:', results);
        return results;
        
    } catch (error) {
        console.error('Error fixing score keys:', error);
        return { error: error.message };
    }
}

// ========================================
// UNIVERSAL ROUND KEY PROCESSOR
// ========================================

/**
 * Universal function to handle round keys with backwards compatibility
 * Use this in all your existing code to handle both old and new formats
 * @param {string} roundKey - Round key to process
 * @returns {object|null} Parsed indices or null if invalid
 */
function getRoundKeyIndices(roundKey) {
    const processed = processRoundKey(roundKey);
    
    if (processed.isValid) {
        if (processed.needsFix) {
            console.warn(`‚ö†Ô∏è Using fixed round key: "${processed.original}" -> "${processed.fixed}"`);
        }
        
        return {
            dayIndex: processed.dayIndex,
            classIndex: processed.classIndex,
            roundIndex: processed.roundIndex,
            standardKey: processed.fixed
        };
    }
    
    console.error(`‚ùå Invalid round key: "${roundKey}"`);
    return null;
}

// ========================================
// INTEGRATION HELPER
// ========================================

/**
 * Replace existing round key parsing in your code with this function
 * Example usage in single-day-trial-report.html:
 * 
 * OLD CODE:
 * const [dayIndex, classIndex, roundIndex] = roundKey.split('-').map(Number);
 * 
 * NEW CODE:
 * const indices = getRoundKeyIndices(roundKey);
 * if (indices) {
 *   const { dayIndex, classIndex, roundIndex } = indices;
 *   // ... rest of your code
 * }
 */
        // Discipline classifications
        const DISCIPLINE_MAPPING = {
            scent: ['PATROL 1', 'DETECTIVE 2', 'INVESTIGATOR 3', 'SUPER SLEUTH 4', 'PRIVATE INV', 'DET DIVERSIONS'],
            games: ['GAMES 1', 'GAMES 2', 'GAMES 3', 'GAMES 4'],
            obedience: ['OBEDIENCE 1', 'OBEDIENCE 2', 'OBEDIENCE 3', 'OBEDIENCE 4', 'OBEDIENCE 5'],
            ranger: ['RANGER 1', 'RANGER 2', 'RANGER 3', 'RANGER 4', 'RANGER 5', 'DASHER 3', 'DASHER 4', 'DASHER 5', 'DASHER 6']
        };

        // Games result codes
        const GAMES_RESULTS = {
            'GB': 'Grab Bag',
            'C': 'Colors', 
            'BJ': 'Black Jack',
            'P': 'Pairs',
            'T': 'Team',
            'Fail': 'Fail',
            'abs': 'Absent'
        };

        // Global variables
        let currentUser = null;
        let currentTrial = null;
        let currentDay = null;
        let reportData = {};
        let activeDiscipline = 'scent';

        // Utility functions
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.textContent = message;
            statusDiv.className = `status-message status-${type}`;
            statusDiv.style.display = 'block';
            
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 5000);
        }

        function createLocalDate(dateStr) {
            if (!dateStr) return null;
            if (typeof dateStr === 'string') {
                const dateWithTime = dateStr.includes('T') ? dateStr : dateStr + 'T12:00:00';
                return new Date(dateWithTime);
            }
            return new Date(dateStr);
        }

        function formatLocalDate(date) {
            if (!date || !(date instanceof Date)) return '';
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function getDateFromFirebase(firebaseDate) {
            if (!firebaseDate) return '';
            let date;
            if (firebaseDate.toDate) {
                date = firebaseDate.toDate();
            } else if (firebaseDate instanceof Date) {
                date = firebaseDate;
            } else if (typeof firebaseDate === 'string') {
                date = createLocalDate(firebaseDate);
            } else {
                return '';
            }
            return formatLocalDate(date);
        }

        function getDisciplineForClass(className) {
            const upperClassName = className.toUpperCase();
            
            for (const [discipline, classes] of Object.entries(DISCIPLINE_MAPPING)) {
                if (classes.some(cls => upperClassName.includes(cls) || cls.includes(upperClassName))) {
                    return discipline;
                }
            }
            
            // Additional fuzzy matching
            if (upperClassName.includes('PATROL') || upperClassName.includes('DETECTIVE') || 
                upperClassName.includes('INVESTIGATOR') || upperClassName.includes('SLEUTH') || 
                upperClassName.includes('PRIVATE') || upperClassName.includes('SCENT')) {
                return 'scent';
            }
            if (upperClassName.includes('GAME')) {
                return 'games';
            }
            if (upperClassName.includes('OBEDIENCE') || upperClassName.includes('RALLY')) {
                return 'obedience';
            }
            if (upperClassName.includes('RANGER') || upperClassName.includes('DASHER')) {
                return 'ranger';
            }
            
            return 'scent'; // Default to scent
        }

        // Initialize the application
        async function init() {
            try {
                await new Promise((resolve, reject) => {
                    const unsubscribe = auth.onAuthStateChanged(async (user) => {
                        unsubscribe();
                        if (user) {
                            try {
                                const userDoc = await db.collection('users').doc(user.uid).get();
                                if (userDoc.exists) {
                                    currentUser = { uid: user.uid, ...userDoc.data() };
                                    resolve();
                                } else {
                                    reject(new Error('User profile not found'));
                                }
                            } catch (error) {
                                reject(error);
                            }
                        } else {
                            window.location.href = 'index.html';
                        }
                    });
                });

                await loadTrials();
            } catch (error) {
                console.error('Error initializing:', error);
                showStatus('Error initializing application: ' + error.message, 'error');
            }
        }

        // Load trials for the dropdown
        async function loadTrials() {
            try {
                showStatus('Loading your trials...', 'info');

                const trialsSnapshot = await db.collection("trials")
                    .where("createdBy", "==", currentUser.uid)
                    .get();

                const trialSelect = document.getElementById('trialSelect');
                trialSelect.innerHTML = '<option value="">Select a trial...</option>';

                if (!trialsSnapshot.empty) {
                    const trials = [];
                    trialsSnapshot.forEach(doc => {
                        trials.push({ id: doc.id, ...doc.data() });
                    });

                    trials.sort((a, b) => {
                        const aTime = a.createdAt ? a.createdAt.seconds : 0;
                        const bTime = b.createdAt ? b.createdAt.seconds : 0;
                        return bTime - aTime;
                    });

                    trials.forEach(trial => {
                        const option = document.createElement('option');
                        option.value = trial.id;
                        option.textContent = trial.clubName || 'Unnamed Trial';
                        trialSelect.appendChild(option);
                    });

                    showStatus(`Found ${trials.length} trials`, 'success');
                } else {
                    showStatus('No trials found', 'error');
                }
            } catch (error) {
                console.error('Error loading trials:', error);
                showStatus('Error loading trials: ' + error.message, 'error');
            }
        }

        // Load trial data and populate day selector
        async function loadTrialData() {
            const trialId = document.getElementById('trialSelect').value;
            const daySelect = document.getElementById('daySelect');
            
            if (!trialId) {
                daySelect.innerHTML = '<option value="">Select a trial first</option>';
                return;
            }

            try {
                showStatus('Loading trial data...', 'info');

                const trialDoc = await db.collection('trials').doc(trialId).get();
                if (!trialDoc.exists) {
                    throw new Error('Trial not found');
                }

                currentTrial = { id: trialDoc.id, ...trialDoc.data() };

                // Fix date handling for trial days
                if (currentTrial.days && Array.isArray(currentTrial.days)) {
                    currentTrial.days = currentTrial.days.map(day => ({
                        ...day,
                        date: day.date ? getDateFromFirebase(day.date) : null
                    }));
                }

                // Populate day dropdown
                daySelect.innerHTML = '<option value="">Select a day...</option>';
                
                if (currentTrial.days && currentTrial.days.length > 0) {
                    currentTrial.days.forEach((day, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        const dayDate = day.date ? new Date(day.date + 'T12:00:00').toLocaleDateString() : `Day ${index + 1}`;
                        option.textContent = dayDate;
                        daySelect.appendChild(option);
                    });
                    
                    showStatus(`Found ${currentTrial.days.length} days`, 'success');
                } else {
                    showStatus('No days found in this trial', 'error');
                }

            } catch (error) {
                console.error('Error loading trial data:', error);
                showStatus('Error loading trial data: ' + error.message, 'error');
            }
        }

        // Helper function to check if entry is FEO (case-insensitive)
function isFeoEntry(entryType) {
    if (!entryType) return false;
    return entryType.toString().toLowerCase() === 'feo';
}

// ===== ENHANCED FEO + ORPHANED SCORE DETECTION =====
let participantCache = new Map();
let entriesData = {}; // Global cache for entries data

// Helper function to check if entry is FEO (case-insensitive)
function isFeoEntry(entryType) {
    if (!entryType) return false;
    const typeStr = entryType.toString().toLowerCase().trim();
    return typeStr === 'feo' || typeStr === 'for exhibition only' || typeStr === 'exhibition';
}

// Enhanced function to determine if participant should be excluded
function shouldExcludeParticipantEnhanced(participant, participantId) {
    // First check for orphaned scores (deleted entries)
    const [docId] = participantId.split('_');
    const originalEntry = entriesData[docId];
    
    if (!originalEntry) {
        console.log(`üö´ ORPHANED SCORE detected (entry deleted): ${participantId}`);
        return true; // Skip orphaned scores from deleted entries
    }

    // Check multiple possible FEO indicators
    if (participant.entryType && isFeoEntry(participant.entryType)) {
        console.log(`üö´ FEO detected via entryType: ${participantId} (${participant.entryType})`);
        return true;
    }

    if (participant.type && isFeoEntry(participant.type)) {
        console.log(`üö´ FEO detected via type: ${participantId} (${participant.type})`);
        return true;
    }

    if (participantId && participantId.toLowerCase().includes('feo')) {
        console.log(`üö´ FEO detected in participantId: ${participantId}`);
        return true;
    }

    if (participant.comments && participant.comments.toLowerCase().includes('feo')) {
        console.log(`üö´ FEO detected in comments: ${participantId} (${participant.comments})`);
        return true;
    }

    // Check original entries data for FEO status
    if (originalEntry.selectedEntries) {
        const parts = participantId.split('_');
        if (parts.length > 1) {
            const entryDetails = parts[1];
            let parsedClassName = '';
            
            // Parse class name from entry details
            const classNames = [
                'Patrol 1', 'Detective 2', 'Investigator 3', 'Super Sleuth 4',
                'Private Inv', 'Det Diversions', 'Ranger 1', 'Ranger 2', 
                'Ranger 3', 'Ranger 4', 'Ranger 5', 'Dasher 3', 'Dasher 4', 
                'Dasher 5', 'Dasher 6'
            ];
            
            for (const className of classNames) {
                if (entryDetails.includes(className)) {
                    parsedClassName = className;
                    break;
                }
            }

            if (parsedClassName) {
                const matchingEntry = originalEntry.selectedEntries.find(se => 
                    se.className === parsedClassName
                );
                if (matchingEntry && matchingEntry.type && isFeoEntry(matchingEntry.type)) {
                    console.log(`üö´ FEO detected via original entries: ${participantId} (${matchingEntry.type})`);
                    return true;
                }
            }
        }
    }

    return false;
}

// Cache for participant details to avoid repeated database calls
        
        // Generate reports for selected trial and day
        async function generateReports() {
            const trialId = document.getElementById('trialSelect').value;
            const dayIndex = document.getElementById('daySelect').value;
            
            if (!trialId || dayIndex === '') {
                showStatus('Please select both trial and day', 'error');
                return;
            }

            try {
                showStatus('Generating reports...', 'info');
                currentDay = parseInt(dayIndex);

                console.log('üîç Looking for data for trial:', trialId, 'day:', currentDay);
                
                // DEBUG: Log the trial structure
                console.log('üèóÔ∏è Trial structure:', currentTrial);
                if (currentTrial && currentTrial.days && currentTrial.days[currentDay]) {
                    console.log('üìÖ Day structure:', currentTrial.days[currentDay]);
                    if (currentTrial.days[currentDay].classes) {
                        currentTrial.days[currentDay].classes.forEach((cls, idx) => {
                            console.log(`üìö Class ${idx}:`, cls);
                            if (cls.rounds) {
                                cls.rounds.forEach((round, rIdx) => {
                                    console.log(`üîÑ Round ${rIdx}:`, round);
                                });
                            }
                        });
                    }
                }

                // ENHANCED DATA LOADING - Look in multiple places
                const allRuns = [];

                // Method 1: Look for individual round scores (preferred for scent work)
                console.log('üìä Method 1: Looking for individual round scores...');
                const scoresSnapshot = await db.collection('scores')
                    .where('trialId', '==', trialId)
                    .get();

                let foundIndividualScores = false;
               for (const doc of scoresSnapshot.docs) {
    const scoreData = doc.data();
    console.log('üîç Found score document:', doc.id, scoreData);
    
    // Check if this score belongs to our selected day
    if (scoreData.roundKey) {
        // Fix malformed round keys like "0--1-0"
        let fixedRoundKey = scoreData.roundKey.replace(/--/g, '-');
        const parts = fixedRoundKey.split('-');
        let dayIdx = parseInt(parts[0]) || 0;
        let classIdx = parseInt(parts[1]) || 0;
        let roundIdx = parseInt(parts[2]) || 0;
        
        // Handle malformed keys like "0--1-0"
        if (parts.length > 3 && parts[1] === '') {
            classIdx = parseInt(parts[2]) || 0;
            roundIdx = parseInt(parts[3]) || 0;
        }
        
        if (dayIdx === currentDay && scoreData.participants) {
            foundIndividualScores = true;
            console.log('‚úÖ Found scores for day', currentDay, ':', Object.keys(scoreData.participants).length, 'participants');
            
            // Process each participant with full details lookup
            for (const [participantId, result] of Object.entries(scoreData.participants)) {
                if (result.passFail) {
                    // Get full participant details from entries collection
                    const participantDetails = await getParticipantDetails(participantId, trialId);
                    
                    // Skip FEO entries
                    if (isFeoEntry(participantDetails.entryType)) {
                        console.log(`üö´ Skipping FEO entry: ${participantId}`);
                        continue;
                    }
                    
                    const discipline = getDisciplineForClass(scoreData.className);
                    const dayDate = currentTrial.days[currentDay].date || '';
                    const formattedDate = dayDate ? new Date(dayDate + 'T12:00:00').toLocaleDateString() : '';
                    
                    allRuns.push({
                        discipline: discipline,
                        cwagsNumber: participantDetails.cwagsNumber, // Now using real data!
                        dogName: participantDetails.dogCallName,     // Now using real data!
                        handlerName: participantDetails.handlerName, // Now using real data!
                        date: formattedDate,
                        className: scoreData.className,
                        roundNumber: scoreData.roundNumber || 1,
                        result: formatResult(result.passFail, discipline),
                        judgeName: scoreData.judgeName || 'TBD',
                        comments: result.comments || '',
                        classOrder: getClassOrder(scoreData.className, discipline)
                    });
                }
            }
        }
    }
}
                // Method 2: Look in running order data if no individual scores found
                if (!foundIndividualScores) {
                    console.log('üìã Method 2: Looking for running order data...');
                    
                    try {
                        const orderDoc = await db.collection('running_orders').doc(trialId).get();
                        if (orderDoc.exists) {
                            const runningOrderData = orderDoc.data();
                            console.log('üîç Found running order data:', Object.keys(runningOrderData));
                            
                            // Get entries data for participant details
                            const entriesSnapshot = await db.collection('entries')
                                .where('trialId', '==', trialId)
                                .get();

                            const entryMap = {};
                            entriesSnapshot.forEach(doc => {
                                entryMap[doc.id] = doc.data();
                            });

                            // Check for different possible field names from running order system
                            let finalizedData = null;
                            if (runningOrderData.finalizedRunningOrders) {
                                finalizedData = runningOrderData.finalizedRunningOrders;
                            } else if (runningOrderData.generatedSheets) {
                                finalizedData = runningOrderData.generatedSheets;
                            } else if (runningOrderData.roundOrders) {
                                finalizedData = runningOrderData.roundOrders;
                            }

                            if (finalizedData) {
                                console.log('üìã Processing running order data:', Object.keys(finalizedData));
                                
                                // Process running order data to create placeholder entries
                                Object.entries(finalizedData).forEach(([roundKey, entryIds]) => {
                                    console.log('üîç Raw round key:', roundKey);
                                    
                                    // Handle different round key formats
                                    let dayIndexFromKey, classIndex, roundIndex;
                                    
                                    if (roundKey.includes('--')) {
                                        // Format: "0--1-0" (day--class-round)
                                        const parts = roundKey.split('--');
                                        dayIndexFromKey = parseInt(parts[0]);
                                        const classRound = parts[1].split('-');
                                        classIndex = parseInt(classRound[0]);
                                        roundIndex = parseInt(classRound[1]);
                                    } else {
                                        // Format: "0-1-0" (day-class-round)
                                        const parts = roundKey.split('-');
                                        dayIndexFromKey = parseInt(parts[0]);
                                        classIndex = parseInt(parts[1]);
                                        roundIndex = parseInt(parts[2]);
                                    }
                                    
                                    console.log('üîç Parsed indices:', { dayIndexFromKey, classIndex, roundIndex });
                                    
                                    if (dayIndexFromKey === currentDay && entryIds && entryIds.length > 0) {
                                        const day = currentTrial.days[dayIndexFromKey];
                                        const cls = day?.classes[classIndex];
                                        const round = cls?.rounds[roundIndex];

                                        console.log(`üîç Processing round ${roundKey}:`, {
                                            day: day,
                                            class: cls,
                                            round: round,
                                            entryCount: entryIds.length
                                        });

                                        if (day && cls && round) {
                                            const roundClassName = cls.className || cls.class || cls.CLASS_NAME;
                                            const discipline = getDisciplineForClass(roundClassName);
                                            const dayDate = currentTrial.days[currentDay].date || '';
                                            const formattedDate = dayDate ? new Date(dayDate + 'T12:00:00').toLocaleDateString() : '';
                                            
                                            // Try multiple judge field names
                                            const judgeName = round.judgeName || round.judge || round.JUDGE_NAME || round.judgname || 'TBD';
                                            
                                            console.log(`üßë‚Äç‚öñÔ∏è Judge for ${roundClassName} Round ${roundIndex + 1}:`, judgeName);
                                            console.log('üîç Round object keys:', Object.keys(round));
                                            
                                            entryIds.forEach(entryId => {
                                                const [docId] = entryId.split('_');
                                                const entry = entryMap[docId];
                                                
                                                if (entry) {
                                                    allRuns.push({
                                                        discipline: discipline,
                                                        cwagsNumber: entry.cwagsNumber || 'TBD',
                                                        dogName: entry.dogCallName || 'Unknown',
                                                        handlerName: entry.handlerName || 'Unknown',
                                                        date: formattedDate,
                                                        className: roundClassName,
                                                        roundNumber: (roundIndex + 1),
                                                        result: 'Scheduled', // Placeholder for unscored runs
                                                        judgeName: judgeName,
                                                        comments: 'Not yet scored',
                                                        classOrder: getClassOrder(roundClassName, discipline),
                                                        roundKey: roundKey
                                                    });
                                                }
                                            });
                                        }
                                    }
                                });
                            }
                        }
                    } catch (orderError) {
                        console.log('‚ö†Ô∏è No running order found:', orderError);
                    }
                }

                // Method 3: Look for entries data even without scores/running orders
                if (allRuns.length === 0) {
                    console.log('üìù Method 3: Looking for basic entry data...');
                    
                    const entriesSnapshot = await db.collection('entries')
                        .where('trialId', '==', trialId)
                        .get();

                    if (!entriesSnapshot.empty) {
                        console.log('üìù Found', entriesSnapshot.size, 'entries for trial');
                        
                        entriesSnapshot.forEach(doc => {
                            const entry = doc.data();
                            
                            if (entry.selectedEntries && Array.isArray(entry.selectedEntries)) {
                                entry.selectedEntries.forEach(selectedEntry => {
                                    const discipline = getDisciplineForClass(selectedEntry.className);
                                    const dayDate = currentTrial.days[currentDay]?.date || '';
                                    const formattedDate = dayDate ? new Date(dayDate + 'T12:00:00').toLocaleDateString() : '';
                                    
                                    allRuns.push({
                                        discipline: discipline,
                                        cwagsNumber: entry.cwagsNumber || 'TBD',
                                        dogName: entry.dogCallName || 'Unknown',
                                        handlerName: entry.handlerName || 'Unknown',
                                        date: formattedDate,
                                        className: selectedEntry.className,
                                        roundNumber: selectedEntry.roundNumber || 1,
                                        result: 'Entry Only', // Just showing the entry exists
                                        judgeName: 'TBD',
                                        comments: 'Entry submitted - no scores yet',
                                        classOrder: getClassOrder(selectedEntry.className, discipline)
                                    });
                                });
                            }
                        });
                    }
                }

                console.log('üìä Total runs found:', allRuns.length);

                if (allRuns.length === 0) {
                    showStatus('No data found for this trial and day. Please ensure entries exist and running orders have been generated.', 'error');
                    document.getElementById('noDataMessage').style.display = 'block';
                    document.getElementById('disciplineTabs').style.display = 'none';
                    return;
                }

                // Group by discipline and sort properly
                reportData = {
                    scent: allRuns.filter(r => r.discipline === 'scent').sort((a, b) => {
                        // Sort by class order, then round number, then C-WAGS number
                        if (a.classOrder !== b.classOrder) return a.classOrder - b.classOrder;
                        if (a.roundNumber !== b.roundNumber) return a.roundNumber - b.roundNumber;
                        const aCwags = a.cwagsNumber === 'TBD' ? 'ZZZ999' : a.cwagsNumber;
                        const bCwags = b.cwagsNumber === 'TBD' ? 'ZZZ999' : b.cwagsNumber;
                        return aCwags.localeCompare(bCwags);
                    }),
                    games: allRuns.filter(r => r.discipline === 'games').sort((a, b) => {
                        if (a.classOrder !== b.classOrder) return a.classOrder - b.classOrder;
                        if (a.roundNumber !== b.roundNumber) return a.roundNumber - b.roundNumber;
                        const aCwags = a.cwagsNumber === 'TBD' ? 'ZZZ999' : a.cwagsNumber;
                        const bCwags = b.cwagsNumber === 'TBD' ? 'ZZZ999' : b.cwagsNumber;
                        return aCwags.localeCompare(bCwags);
                    }),
                    obedience: allRuns.filter(r => r.discipline === 'obedience').sort((a, b) => {
                        if (a.classOrder !== b.classOrder) return a.classOrder - b.classOrder;
                        if (a.roundNumber !== b.roundNumber) return a.roundNumber - b.roundNumber;
                        const aCwags = a.cwagsNumber === 'TBD' ? 'ZZZ999' : a.cwagsNumber;
                        const bCwags = b.cwagsNumber === 'TBD' ? 'ZZZ999' : b.cwagsNumber;
                        return aCwags.localeCompare(bCwags);
                    }),
                    ranger: allRuns.filter(r => r.discipline === 'ranger').sort((a, b) => {
                        if (a.classOrder !== b.classOrder) return a.classOrder - b.classOrder;
                        if (a.roundNumber !== b.roundNumber) return a.roundNumber - b.roundNumber;
                        const aCwags = a.cwagsNumber === 'TBD' ? 'ZZZ999' : a.cwagsNumber;
                        const bCwags = b.cwagsNumber === 'TBD' ? 'ZZZ999' : b.cwagsNumber;
                        return aCwags.localeCompare(bCwags);
                    })
                };

                console.log('üìä Discipline breakdown:', {
                    scent: reportData.scent.length,
                    games: reportData.games.length,
                    obedience: reportData.obedience.length,
                    ranger: reportData.ranger.length
                });

                renderReports();
                document.getElementById('disciplineTabs').style.display = 'flex';
                document.getElementById('noDataMessage').style.display = 'none';
                showStatus('Reports generated successfully!', 'success');

            } catch (error) {
                console.error('Error generating reports:', error);
                showStatus('Error generating reports: ' + error.message, 'error');
            }
        }

        // Format result based on discipline
        function formatResult(passFail, discipline) {
            if (discipline === 'games') {
                // For games, we'd need additional logic to determine specific game type
                // For now, return generic pass/fail
                return passFail === 'Pass' ? 'P' : 'Fail';
            }
            return passFail === 'Pass' ? 'Pass' : 'Fail';
        }

        // Get class order for sorting
        function getClassOrder(className, discipline) {
            const upperClassName = className.toUpperCase();
            
            if (discipline === 'scent') {
                if (upperClassName.includes('PATROL 1')) return 1;
                if (upperClassName.includes('DETECTIVE 2')) return 2;
                if (upperClassName.includes('INVESTIGATOR 3')) return 3;
                if (upperClassName.includes('SUPER SLEUTH 4')) return 4;
                if (upperClassName.includes('PRIVATE')) return 5;
                if (upperClassName.includes('DET DIVERSIONS')) return 6;
            } else if (discipline === 'games') {
                if (upperClassName.includes('GAMES 1')) return 1;
                if (upperClassName.includes('GAMES 2')) return 2;
                if (upperClassName.includes('GAMES 3')) return 3;
                if (upperClassName.includes('GAMES 4')) return 4;
            } else if (discipline === 'obedience') {
                if (upperClassName.includes('OBEDIENCE 1')) return 1;
                if (upperClassName.includes('OBEDIENCE 2')) return 2;
                if (upperClassName.includes('OBEDIENCE 3')) return 3;
                if (upperClassName.includes('OBEDIENCE 4')) return 4;
                if (upperClassName.includes('OBEDIENCE 5')) return 5;
            } else if (discipline === 'ranger') {
                if (upperClassName.includes('RANGER 1')) return 1;
                if (upperClassName.includes('RANGER 2')) return 2;
                if (upperClassName.includes('RANGER 3')) return 3;
                if (upperClassName.includes('RANGER 4')) return 4;
                if (upperClassName.includes('RANGER 5')) return 5;
                if (upperClassName.includes('DASHER 3')) return 6;
                if (upperClassName.includes('DASHER 4')) return 7;
                if (upperClassName.includes('DASHER 5')) return 8;
                if (upperClassName.includes('DASHER 6')) return 9;
            }
            
            return 999; // Default for unrecognized classes
        }

        // Render all reports
        function renderReports() {
            ['scent', 'games', 'obedience', 'ranger'].forEach(discipline => {
                renderDisciplineReport(discipline);
            });
        }

        // Render specific discipline report
        function renderDisciplineReport(discipline) {
            const runs = reportData[discipline] || [];
            const tbody = document.getElementById(`${discipline}TableBody`);
            const info = document.getElementById(`${discipline}ReportInfo`);
            const stats = document.getElementById(`${discipline}Stats`);
            
            // Update info
            const dayDate = currentTrial.days[currentDay].date ? 
                new Date(currentTrial.days[currentDay].date + 'T12:00:00').toLocaleDateString() : 'Date TBD';
            info.textContent = `${currentTrial.clubName} ‚Ä¢ ${dayDate} ‚Ä¢ ${runs.length} entries`;
            
            // Generate statistics
            const totalRuns = runs.length;
            const passes = runs.filter(r => r.result === 'Pass' || r.result === 'P').length;
            const fails = runs.filter(r => r.result === 'Fail' || r.result === 'F').length;
            const scheduled = runs.filter(r => r.result === 'Scheduled' || r.result === 'Entry Only').length;
            const passRate = (totalRuns - scheduled) > 0 ? (((passes / (totalRuns - scheduled)) * 100).toFixed(1)) : '0';
            
            // Group runs by class and round for better organization
            const groupedRuns = {};
            runs.forEach(run => {
                const key = `${run.className} Round ${run.roundNumber}`;
                if (!groupedRuns[key]) {
                    groupedRuns[key] = {
                        className: run.className,
                        roundNumber: run.roundNumber,
                        judgeName: run.judgeName,
                        runs: []
                    };
                }
                groupedRuns[key].runs.push(run);
            });
            
            stats.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${totalRuns}</div>
                    <div class="stat-label">Total Entries</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${Object.keys(groupedRuns).length}</div>
                    <div class="stat-label">Rounds</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${passes}</div>
                    <div class="stat-label">Passes</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${fails}</div>
                    <div class="stat-label">Fails</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${scheduled}</div>
                    <div class="stat-label">Not Scored</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${passRate}%</div>
                    <div class="stat-label">Pass Rate</div>
                </div>
            `;
            
            // Generate table rows - grouped by round
            tbody.innerHTML = '';
            
            if (runs.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="9" style="text-align: center; color: #6c757d; font-style: italic; padding: 2rem;">
                            No ${discipline} entries found for this day
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Sort groups by class order and round number
            const sortedGroups = Object.values(groupedRuns).sort((a, b) => {
                const aOrder = getClassOrder(a.className, discipline);
                const bOrder = getClassOrder(b.className, discipline);
                if (aOrder !== bOrder) return aOrder - bOrder;
                return a.roundNumber - b.roundNumber;
            });
            
            sortedGroups.forEach((group, groupIndex) => {
                // Add a header row for each round
                const headerRow = document.createElement('tr');
                headerRow.style.backgroundColor = '#e9ecef';
                headerRow.style.fontWeight = 'bold';
                headerRow.innerHTML = `
                    <td colspan="9" style="text-align: center; padding: 1rem; font-size: 1rem;">
                        ${group.className} Round ${group.roundNumber} - Judge: ${group.judgeName} 
                        (${group.runs.length} entries)
                    </td>
                `;
                tbody.appendChild(headerRow);
                
                // Sort runs within group by C-WAGS number
                group.runs.sort((a, b) => {
                    const aNum = a.cwagsNumber === 'TBD' ? '999999' : a.cwagsNumber;
                    const bNum = b.cwagsNumber === 'TBD' ? '999999' : b.cwagsNumber;
                    return aNum.localeCompare(bNum);
                });
                
                // Add rows for each participant in this round
                group.runs.forEach(run => {
                    const row = document.createElement('tr');
                    
                    let resultClass = 'result-absent';
                    if (run.result === 'Pass' || run.result === 'P') resultClass = 'result-pass';
                    else if (run.result === 'Fail' || run.result === 'F') resultClass = 'result-fail';
                    else if (discipline === 'games' && ['GB', 'C', 'BJ', 'P', 'T'].includes(run.result)) resultClass = 'result-games';
                    else if (run.result === 'Scheduled' || run.result === 'Entry Only') resultClass = 'result-absent';
                    
                    row.innerHTML = `
                        <td style="font-weight: bold;">${run.cwagsNumber}</td>
                        <td>${run.dogName}</td>
                        <td>${run.handlerName}</td>
                        <td>${run.date}</td>
                        <td style="font-size: 0.8rem;">${run.className}</td>
                        <td style="text-align: center;">${run.roundNumber}</td>
                        <td class="${resultClass}" style="text-align: center; font-weight: bold;">${run.result}</td>
                        <td style="font-size: 0.8rem;">${run.judgeName}</td>
                        <td contenteditable="true" style="background: #f8f9fa; font-size: 0.8rem;">${run.comments}</td>
                    `;
                    
                    tbody.appendChild(row);
                });
                
                // Add a spacer row between groups (except for the last one)
                if (groupIndex < sortedGroups.length - 1) {
                    const spacerRow = document.createElement('tr');
                    spacerRow.innerHTML = `<td colspan="9" style="height: 10px; border: none;"></td>`;
                    tbody.appendChild(spacerRow);
                }
            });
        }

        // Show specific discipline tab
        function showDiscipline(discipline) {
            // Update tab states
            document.querySelectorAll('.discipline-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.report-container').forEach(container => container.style.display = 'none');
            
            // Activate selected discipline
            event.target.classList.add('active');
            document.getElementById(`${discipline}Report`).style.display = 'block';
            activeDiscipline = discipline;
        }

        // Export discipline as CSV
        function exportDisciplineCSV(discipline) {
            const runs = reportData[discipline] || [];
            
            if (runs.length === 0) {
                showStatus(`No ${discipline} data to export`, 'error');
                return;
            }

            try {
                let csvContent = '';
                
                // Header
                const disciplineNames = {
                    scent: 'Scent (Detective)',
                    games: 'Games',
                    obedience: 'Rally Obedience',
                    ranger: 'Ranger/Dasher'
                };
                
                csvContent += `"${disciplineNames[discipline]} Disciplines Report"\n`;
                csvContent += `"Trial","${currentTrial.clubName}"\n`;
                const dayDate = currentTrial.days[currentDay].date ? 
                    new Date(currentTrial.days[currentDay].date + 'T12:00:00').toLocaleDateString() : 'Date TBD';
                csvContent += `"Date","${dayDate}"\n`;
                csvContent += `"Generated","${new Date().toLocaleDateString()}"\n`;
                csvContent += `\n`; // Empty line
                
                // Table headers
                csvContent += '"C-WAGS #","Call Name","Handler","Date","Class","Round","Result","Judge","Comments"\n';
                
                // Data rows
                runs.forEach(run => {
                    csvContent += `"${run.cwagsNumber}","${run.dogName}","${run.handlerName}","${run.date}","${run.className}","${run.roundNumber}","${run.result}","${run.judgeName}","${run.comments}"\n`;
                });
                
                // Download
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${disciplineNames[discipline].replace(/[^a-zA-Z0-9]/g, '_')}_Report.csv`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                showStatus(`${disciplineNames[discipline]} CSV exported successfully!`, 'success');
            } catch (error) {
                console.error('Error exporting CSV:', error);
                showStatus('Error exporting CSV: ' + error.message, 'error');
            }
        }

        // Export discipline as PDF
        function exportDisciplinePDF(discipline) {
            const runs = reportData[discipline] || [];
            
            if (runs.length === 0) {
                showStatus(`No ${discipline} data to export`, 'error');
                return;
            }

            try {
                const disciplineNames = {
                    scent: 'Scent (Detective)',
                    games: 'Games',
                    obedience: 'Rally Obedience',
                    ranger: 'Ranger/Dasher'
                };
                
                const printWindow = window.open('', '_blank');
                const dayDate = currentTrial.days[currentDay].date ? 
                    new Date(currentTrial.days[currentDay].date + 'T12:00:00').toLocaleDateString() : 'Date TBD';
                
                const htmlContent = `
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>${disciplineNames[discipline]} Report</title>
                        <style>
                            body { font-family: Arial, sans-serif; margin: 20px; font-size: 12px; }
                            .header { text-align: center; margin-bottom: 20px; }
                            .title { font-size: 18px; font-weight: bold; margin-bottom: 10px; }
                            .info { font-size: 12px; color: #666; margin-bottom: 5px; }
                            table { width: 100%; border-collapse: collapse; margin-top: 20px; }
                            th, td { border: 1px solid #ddd; padding: 6px; text-align: left; font-size: 10px; }
                            th { background-color: #f5f5f5; font-weight: bold; }
                            .result-pass { color: #28a745; font-weight: bold; }
                            .result-fail { color: #dc3545; font-weight: bold; }
                            .result-games { color: #17a2b8; font-weight: bold; }
                            @media print { body { margin: 0; } }
                        </style>
                    </head>
                    <body>
                        <div class="header">
                            <div class="title">${disciplineNames[discipline]} Disciplines Report</div>
                            <div class="info">Trial: ${currentTrial.clubName}</div>
                            <div class="info">Date: ${dayDate}</div>
                            <div class="info">Generated: ${new Date().toLocaleDateString()}</div>
                        </div>
                        
                        <table>
                            <thead>
                                <tr>
                                    <th>C-WAGS #</th>
                                    <th>Call Name</th>
                                    <th>Handler</th>
                                    <th>Date</th>
                                    <th>Class</th>
                                    <th>Round</th>
                                    <th>Result</th>
                                    <th>Judge</th>
                                    <th>Comments</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${runs.map(run => {
                                    let resultClass = '';
                                    if (run.result === 'Pass' || run.result === 'P') resultClass = 'result-pass';
                                    else if (run.result === 'Fail' || run.result === 'F') resultClass = 'result-fail';
                                    else if (discipline === 'games' && ['GB', 'C', 'BJ', 'P', 'T'].includes(run.result)) resultClass = 'result-games';
                                    
                                    return `<tr>
                                        <td>${run.cwagsNumber}</td>
                                        <td>${run.dogName}</td>
                                        <td>${run.handlerName}</td>
                                        <td>${run.date}</td>
                                        <td>${run.className}</td>
                                        <td>${run.roundNumber}</td>
                                        <td class="${resultClass}">${run.result}</td>
                                        <td>${run.judgeName}</td>
                                        <td>${run.comments}</td>
                                    </tr>`;
                                }).join('')}
                            </tbody>
                        </table>
                    </body>
                    </html>
                `;
                
                printWindow.document.write(htmlContent);
                printWindow.document.close();
                
                printWindow.onload = function() {
                    printWindow.print();
                };

                showStatus(`${disciplineNames[discipline]} PDF export opened`, 'success');
            } catch (error) {
                console.error('Error exporting PDF:', error);
                showStatus('Error exporting PDF: ' + error.message, 'error');
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing single-day trial report system...');
            init();
        });

        console.log('Single-Day Trial Report script loaded successfully');
    </script>
</body>
</html>
